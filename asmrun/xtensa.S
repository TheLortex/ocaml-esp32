#include "caml/m.h"
    .global caml_garbage_collection
    .literal_position

    .text
    .literal_position
    .globl caml_system__code_begin
caml_system__code_begin:

    .align  4
    .globl  caml_call_gc
/*
    Calls generated by emit.mlp
    Updates f1 and f2 after garbage collection.
    -> Called using CALL0 ABI.
    a2 and a3 are saved.
 */
caml_call_gc:
/* Record return address */
    .literal __caml_last_return_address, caml_last_return_address
    l32r    a15, __caml_last_return_address
    s32i    a0, a15, 0
.Lcaml_call_gc:
/* Record lowest stack address */
    .literal __caml_bottom_of_stack, caml_bottom_of_stack
    l32r    a15, __caml_bottom_of_stack
    s32i    sp, a15, 0
/* Save stack pointer */
    .literal __caml_gc_regs, caml_gc_regs
    l32r    a15, __caml_gc_regs
    s32i    sp, a15, 0
/* Save allocation pointer */
    .literal __caml_young_ptr, caml_young_ptr
    l32r    a15, __caml_young_ptr
    ssi     f1, a15, 0
/* Save trap pointer */
    .literal __caml_exception_pointer, caml_exception_pointer
    l32r    a15, __caml_exception_pointer
    ssi     f0, a15, 0
/* Call the garbage collector: C call saves a0-a3 */
    call4   caml_garbage_collection
/* Reload new allocation pointer and limit */
    l32r    a15, __caml_young_ptr
    lsi     f1, a15, 0 /* Load new alloc_ptr */
    .literal __caml_young_limit, caml_young_limit
    l32r    a15, __caml_young_limit
    lsi     f2, a15, 0 /* Load new alloc_limit */
/* Return to caller */
    ret
    .type   caml_call_gc, %function
    .size   caml_call_gc, .-caml_call_gc

    .literal_position


    .align  4
    .globl  caml_alloc1
/*
-> Called using CALL0 ABI.
Destroys every register
 */
caml_alloc1:
.Lcaml_alloc1:
    rfr     a2, f1      /* Read alloc ptr */
    rfr     a3, f2      /* Read alloc limit */
    addi    a2, a2, -8  /* Perform update */
    bltu    a2, a3, 1f  /* Call gc on overflow */
    wfr     f1, a2      /* Write new alloc ptr */
    ret
1:  /* Record return address */
    l32r    a2, __caml_last_return_address
    s32i    a0, a2, 0
    /* Call GC which will update f1 and f2 (alloc pointer and limit), saving a2 and a3 */
    call0   .Lcaml_call_gc
    /* Restore return address */
    l32i    a0, a2, 0
    j       .Lcaml_alloc1
    .type   caml_alloc1, %function
    .size   caml_alloc1, .-caml_alloc1


    .align  4
    .globl  caml_alloc2
/*
-> Called using CALL0 ABI.
Destroys every register
 */
caml_alloc2:
.Lcaml_alloc2:
    rfr     a2, f1      /* Read alloc ptr */
    rfr     a3, f2      /* Read alloc limit */
    addi    a2, a2, -12 /* Perform update */
    bltu    a2, a3, 1f  /* Call gc on overflow */
    wfr     f1, a2      /* Write new alloc ptr */
    ret
1:  /* Record return address */
    l32r    a2, __caml_last_return_address
    s32i    a0, a2, 0
    /* Call GC which will update f1 and f2 (alloc pointer and limit), saving a2 and a3 */
    call0   .Lcaml_call_gc
    /* Restore return address */
    l32i    a0, a2, 0
    j       .Lcaml_alloc2
    .type   caml_alloc2, %function
    .size   caml_alloc2, .-caml_alloc2

    .align  4
    .globl  caml_alloc3
/*
-> Called using CALL0 ABI.
Destroys every register
 */
caml_alloc3:
.Lcaml_alloc3:
    rfr     a2, f1      /* Read alloc ptr */
    rfr     a3, f2      /* Read alloc limit */
    addi    a2, a2, -16 /* Perform update */
    bltu    a2, a3, 1f  /* Call gc on overflow */
    wfr     f1, a2      /* Write new alloc ptr */
    ret
1:  /* Record return address */
    l32r    a2, __caml_last_return_address
    s32i    a0, a2, 0
    /* Call GC which will update f1 and f2 (alloc pointer and limit), saving a2 and a3 */
    call0   .Lcaml_call_gc
    /* Restore return address */
    l32i    a0, a2, 0
    j       .Lcaml_alloc3
    .type   caml_alloc3, %function
    .size   caml_alloc3, .-caml_alloc3

/* N bytes allocation, N is in a2
-> Called using CALL0 ABI.
Destroys every register except a2
*/
    .align  4
    .globl  caml_allocN
caml_allocN:
.Lcaml_allocN:
    rfr     a3, f1      /* Read alloc ptr */
    sub     a3, a3, a2  /* Perform update */
    rfr     a4, f2      /* Read alloc limit */
    bltu    a3, a4, 1f  /* Call gc on overflow */
    wfr     f1, a3      /* Write new alloc ptr */
    ret
1:  /* Record return address */
    l32r    a3, __caml_last_return_address
    s32i    a0, a3, 0
    /* Call GC which will update f1 and f2 (alloc pointer and limit), saving a2 and a3 */
    call0   .Lcaml_call_gc
    /* Restore return address */
    l32i    a0, a3, 0
    j       .Lcaml_allocN
    .type   caml_allocN, %function
    .size   caml_allocN, .-caml_allocN


    .literal_position

/* Call a C function from OCaml
-> Called using CALL0 ABI.
a6 to a11 contains function arguments
a4 contains C function to call.
a2 and a3 should be saved.
-> C is called using CALL4 ABI.
*/
    .align  4
    .globl  caml_c_call
caml_c_call:
/* Record lowest stack address and return address */
    l32r    a12, __caml_last_return_address
    l32r    a13, __caml_bottom_of_stack
    s32i    a0, a12, 0
    s32i    sp, a13, 0
/* Make the exception handler alloc ptr available to the C code */
    l32r    a12, __caml_young_ptr
    l32r    a13, __caml_exception_pointer
    ssi     f1, a12, 0
    ssi     f0, a13, 0
/* Call the C function. a0-a3 are saved. */
    callx4  a4
/* Reload alloc ptr and alloc limit into registers */
    l32r    a12, __caml_young_ptr
    l32r    a13, __caml_young_limit
    lsi     f1, a12, 0
    lsi     f2, a13, 0
/* Return */
    ret
    .type   caml_c_call, %function
    .size   caml_c_call, .-caml_c_call

    .literal_position

/* Start the OCalm program - CALL8*/
    .align  4
    .globl  caml_start_program
caml_start_program:
    entry   sp, 3*16
.literal __caml_program, caml_program
    l32r    a11, __caml_program

/* Code shared with caml_callback */
/* Address of OCaml code to call is in a11 */
/* Arguments to the OCaml code are in a2...a7 */
/* Nothing is saved. */

 /* Base windowed call is 16 bytes
  * Stack uses 16 bytes for bottom, last_return, gc, a0
  * + 16 bytes for trap: caml_exception_pointer, .Ltrap_handler
  */
.Ljump_to_caml:
/* Setup a callback link on the stack */
    l32r    a8, __caml_bottom_of_stack
    l32r    a9, __caml_last_return_address
    l32r    a10, __caml_gc_regs
    l32i    a8, a8, 0
    l32i    a9, a9, 0
    l32i    a10, a10, 0
    s32i    a8, sp, 16
    s32i    a9, sp, 20
    s32i    a10, sp, 24
/* Save return address */
    s32i    a0, sp, 28
/* Setup a trap frame to catch exceptions escaping the OCaml code */
    l32r    a8, __caml_exception_pointer
    .literal .trap_handler, trap_handler
    l32r    a9, .trap_handler
    l32i    a8, a8, 0
    s32i    a8, sp, 0 /* exn ptr */
    s32i    a9, sp, 4 /* trap handler */
    wfr     f0, sp  /* Save trap pointer */
/* Reload allocation pointers */
    l32r    a8, __caml_young_ptr
    lsi     f1, a8, 0
    l32r    a8, __caml_young_limit
    lsi     f2, a8, 0
/* Move arguments for C ABI call */
    mov     a8, a11
/* Call the OCaml code */
    callx0  a8
.Lcaml_retaddr:
/* Pop the trap frame, restoring caml_exception_pointer */
    l32r    a8, __caml_exception_pointer
    l32i    a9, sp, 0
    s32i    a9, a8, 0
    addi    a15, sp, 16
/* Fake call8 for correct movsp */
    movi    a0, 2
    slli	a0, a0, 30
    movsp   sp, a15
/* Pop the callback link, restoring the global variables */
.Lreturn_result:
    l32r    a8, __caml_bottom_of_stack
    l32i    a9, sp, 0
    s32i    a9, a8, 0
    l32r    a8, __caml_last_return_address
    l32i    a9, sp, 4
    s32i    a9, a8, 0
    l32r    a8, __caml_gc_regs
    l32i    a9, sp, 8
    s32i    a9, a8, 0
/* Return address */
    l32i    a0, sp, 12
/* Update allocation pointer */
    l32r    a8, __caml_young_ptr
    ssi     f1, a8, 0
    retw
    .type   .Lcaml_retaddr, %function
    .size   .Lcaml_retaddr, .-.Lcaml_retaddr
    .type   caml_start_program, %function
    .size   caml_start_program, .-caml_start_program

    .literal_position


    .align 4
    .globl trap_handler
trap_handler:
/* Save exception pointer */
    l32r    a11, __caml_exception_pointer
    ssi     f0, a11, 0
/* Encode exception bucket as an exception result */
    movi    a11, 2
    or      a2, a2, a11
/* Return it */
    j       .Lreturn_result
    .type   trap_handler, %function
    .size   trap_handler, .-trap_handler

    .literal_position


/* Raise an exception from OCaml */
/* CALL0 */
    .align  4
    .globl  caml_raise_exn
caml_raise_exn:
/* Test if backtrace is active */
    .literal __caml_backtrace_active, caml_backtrace_active
    l32r    a3, __caml_backtrace_active
    l32i    a3, a3, 0
    beqz    a3, 1f
/* Give exception bucket as argument */
    mov     a6, a2
/* Stash the backtrace */
    mov     a7, a0
    mov     a8, sp
    rfr     a9, f0
    call4   caml_stash_backtrace
1:
/* Cut stack at current trap handler */
    rfr     a15, f0
/* Pop previous trap handler */
    lsi     f0, a15, 0
/* Load trap destination in f5 (then it will be loaded in a0) */
    lsi     f5, a15, 4
/* Set new stack using movsp and a fake call8 */
    movi    a14, 2
    slli    a0, a14, 30
    addi    a15, a15, 16
    movsp   sp, a15
    rfr     a0, f5
    ret
    .literal_position


/* Raise an exception from C */

/* Check window stuff */
    .align 4
    .globl caml_raise_exception
caml_raise_exception:
    entry   sp, 16
/* Spill all registers on stack. saving a2 */
    mov     a4, a2
    movi    a2, 0
    syscall
    mov a2, a4
/* Reload trap ptr, alloc ptr and alloc limit in f0, f1, f2 */
    l32r    a12, __caml_exception_pointer
    l32r    a13, __caml_young_ptr
    l32r    a14, __caml_young_limit
    lsi     f0, a12, 0
    lsi     f1, a13, 0
    lsi     f2, a14, 0
/* Test if backtrace is active */
    l32r    a3, __caml_backtrace_active
    l32i    a3, a3, 0
    beqz    a3, 1f 
/* Preserve exception bucket in callee-save register a2 */
    mov     a6, a2
    l32r    a7, __caml_last_return_address
    l32i    a7, a7, 0
    l32r    a8, __caml_bottom_of_stack
    l32i    a8, a8, 0
    rfr     a9, f0
    call4   caml_stash_backtrace 
1:
/* Cut stack at bottom of stack before C call to get back caller's spilled registers */
    l32r    a15, __caml_bottom_of_stack
    l32i    sp, a15, 0
/* Under SP there are 4 spilled registers of OCaml code caller */

/* Find stack pointer at current trap handler */
    rfr     a15, f0
/* Pop previous trap handler */
    lsi     f0, a15, 0
/* Load trap destination */
    l32i    a0, a15, 4
/* Erase two high bits */
    slli    a0, a0, 2
    srli    a0, a0, 2
/* Set as call4 */
    movi    a3, 1
    slli    a3, a3, 30
    or      a0, a3, a0
/* a15 holds new stack pointer */
    addi    a15, a15, 16
/* under a15 there will be a0-a3 registers updated on OCaml retw */
/* under sp there will be a0-a3 registers updated on exception retw */
    .globl after_syscall
after_syscall:
    l32e    a11, sp, -4 
    l32e    a12, sp, -8 
    l32e    a13, sp, -12
    l32e    a14, sp, -16
    s32e    a11, a15, -4 
    s32e    a12, a15, -8 
    s32e    a13, a15, -12
    s32e    a14, a15, -16
/* Store trap sp, that will be set in register on window underflow */
    s32e    a15, sp, -12 /* a1 */
    s32e    a2, sp, -8 /* a2 */
/* Jump on trap handler and underflow, restoring stack pointer. */
    retw

    .type   caml_raise_exception, %function
    .size   caml_raise_exception, .-caml_raise_exception


/* Callback from C to OCaml */

    .align  4
    .globl  caml_callback_exn
caml_callback_exn:
    entry   sp, 3*16
/* Initial shuffling of argments (a2 = closure, a3 = first arg) */
    mov     a11, a2
    mov     a2, a3      /* a2 = first arg */
    mov     a3, a11     /* a3 = closure environment */
    l32i    a11, a11, 0 /* code pointer */
    j       .Ljump_to_caml
    .type   caml_callback_exn, %function
    .size   caml_callback_exn, .-caml_callback_exn

    .literal_position

    .align  4
    .globl  caml_callback2_exn
caml_callback2_exn:
    entry   sp, 3*16
/* Initial shuffling of argments (a2 = closure, a3 = arg1, a4 = arg2) */
    mov     a11, a2
    mov     a2, a3      /* a2 = first arg */
    mov     a3, a4      /* a3 = second arg */
    mov     a4, a11     /* a4 = closure environment */
    l32i    a11, a11, 0 /* code pointer */
    j       .Ljump_to_caml
    .type   caml_callback2_exn, %function
    .size   caml_callback2_exn, .-caml_callback2_exn

    .literal_position

    .align  4
    .globl  caml_callback3_exn
caml_callback3_exn:
    entry   sp, 3*16
/* Initial shuffling of argments (a2 = closure, a3 = arg1, a4 = arg2, a5 = arg3) */
    mov     a11, a2
    mov     a2, a3      /* a2 = first arg */
    mov     a3, a4      /* a3 = first arg */
    mov     a4, a5      /* a4 = first arg */
    mov     a5, a11     /* a5 = closure environment */
    l32i    a11, a11, 0 /* code pointer */
    j       .Ljump_to_caml
    .type   caml_callback3_exn, %function
    .size   caml_callback3_exn, .-caml_callback3_exn

    .literal_position


    .align  4
    .globl  caml_ml_array_bound_error
caml_ml_array_bound_error:
/* Load address of [caml_array_bound_error] in */
    .literal __caml_array_bound_error, caml_array_bound_error
    l32r    a9, __caml_array_bound_error
/* Call that function */
    call0   caml_c_call
    ret
    .type   caml_ml_array_bound_error, %function
    .size   caml_ml_array_bound_error, .-caml_ml_array_bound_error

    .literal_position

    .globl  caml_system__code_end
caml_system__code_end:

/* GC roots for callback */

    .data
    .align  4
    .globl  caml_system__frametable
caml_system__frametable:
    .word   1               /* one descriptor */
    .word   .Lcaml_retaddr  /* return address into callback */
    .short  -1              /* negative frame size => use callback link */
    .short  0               /* no roots */
    .align  2
    .type   caml_system__frametable, %object
    .size   caml_system__frametable, .-caml_system__frametable

/* Mark stack as non-executable */
    .section .note.GNU-stack,"",%progbits
