#include "caml/m.h"
    .global caml_garbage_collection
    .literal_position
    
    .text
    .literal_position
    .globl caml_system__code_begin
caml_system__code_begin:
    
    .align  4
    .globl  caml_call_gc
/* 
    Calls generated by emit.mlp
    Updates f1 and f2 after garbage collection.
    -> Called using CALL0 ABI. 
    Destroys a2, a3
 */
caml_call_gc:
/* Record return address */
    .literal __caml_last_return_address, caml_last_return_address
    l32r    a2, __caml_last_return_address
    s32i    a0, a2, 0
.Lcaml_call_gc:
/* Record lowest stack address */
    .literal __caml_bottom_of_stack, caml_bottom_of_stack
    l32r    a2, __caml_bottom_of_stack
    s32i    sp, a2, 0
/* Save stack pointer */
    .literal __caml_gc_regs, caml_gc_regs
    l32r    a2, __caml_gc_regs
    s32i    sp, a2, 0
/* Save allocation pointer */
    .literal __caml_young_ptr, caml_young_ptr
    l32r    a3, __caml_young_ptr
    ssi     f1, a3, 0
/* Save trap pointer */
    .literal __caml_exception_pointer, caml_exception_pointer
    l32r    a2, __caml_exception_pointer
    ssi     f0, a2, 0
/* Call the garbage collector: C call saves a0-a3 */
    call4   caml_garbage_collection
/* Reload new allocation pointer and limit */
    .literal __caml_young_limit, caml_young_limit
    l32r    a2, __caml_young_limit
    lsi     f1, a3, 0 /* Load new alloc_ptr */
    lsi     f2, a2, 0 /* Load new alloc_limit */
/* Return to caller */
    ret
    .type   caml_call_gc, %function
    .size   caml_call_gc, .-caml_call_gc

    .literal_position
    

    .align  4
    .globl  caml_alloc1
/*
-> Called using CALL0 ABI. 
Destroys a2, a3
 */
caml_alloc1:
.Lcaml_alloc1:
    rfr     a2, f1      /* Read alloc ptr */
    rfr     a3, f2      /* Read alloc limit */
    addi    a2, a2, -8  /* Perform update */
    bltu    a2, a3, 1f  /* Call gc on overflow */
    wfr     f1, a2      /* Write new alloc ptr */
    ret
1: 
    call4   caml_call_gc 
    j       .Lcaml_alloc1 
    .type   caml_alloc1, %function 
    .size   caml_alloc1, .-caml_alloc1 


    .align  4
    .globl  caml_alloc2
/*
-> Called using CALL0 ABI. 
Destroys a2, a3
 */
caml_alloc2:
.Lcaml_alloc2:
    rfr     a2, f1      /* Read alloc ptr */
    rfr     a3, f2      /* Read alloc limit */
    addi    a2, a2, -12 /* Perform update */
    bltu    a2, a3, 1f  /* Call gc on overflow */
    wfr     f1, a2      /* Write new alloc ptr */
    ret
1: 
    call4   caml_call_gc 
    j       .Lcaml_alloc2 
    .type   caml_alloc2, %function 
    .size   caml_alloc2, .-caml_alloc2

    .align  4
    .globl  caml_alloc3
/*
-> Called using CALL0 ABI.
Destroys a2, a3 
 */
caml_alloc3:
.Lcaml_alloc3:
    rfr     a2, f1      /* Read alloc ptr */
    rfr     a3, f2      /* Read alloc limit */
    addi    a2, a2, -16 /* Perform update */
    bltu    a2, a3, 1f  /* Call gc on overflow */
    wfr     f1, a2      /* Write new alloc ptr */
    ret
1: 
    call4   caml_call_gc 
    j       .Lcaml_alloc3 
    .type   caml_alloc3, %function 
    .size   caml_alloc3, .-caml_alloc3 

/* N bytes allocation, N is in a2 
-> Called using CALL0 ABI.
Destroys a2, a3 
*/
    .align  4
    .globl  caml_allocN
caml_allocN:
.Lcaml_allocN:
    rfr     a3, f1      /* Read alloc ptr */
    sub     a3, a3, a2  /* Perform update */
    rfr     a2, f2      /* Read alloc limit */
    bltu    a3, a2, 1f  /* Call gc on overflow */
    wfr     f1, a3      /* Write new alloc ptr */
    ret
1: 
    call4   caml_call_gc 
    j       .Lcaml_allocN
    .type   caml_allocN, %function 
    .size   caml_allocN, .-caml_allocN 


    .literal_position
    
/* Call a C function from OCaml
-> Called using CALL0 ABI. 
a2 to a7 contains function arguments
a9 contains C function to call. 
-> C is called using CALL8 ABI. 
a10 to a15 must contain function arguments
*/
    .align  4
    .globl  caml_c_call
caml_c_call:
    mov     a8, a9
/* Record lowest stack address and return address */
    l32r    a9, __caml_last_return_address
    l32r    a10, __caml_bottom_of_stack
    s32i    a0, a9, 0 
    s32i    sp, a10, 0
/* Make the exception handler alloc ptr available to the C code */
    l32r    a9, __caml_young_ptr
    l32r    a10, __caml_exception_pointer
    ssi     f1, a9, 0
    ssi     f0, a10, 0
/* Move arguments for C ABI call */
    mov     a10, a2 
    mov     a11, a3 
    mov     a12, a4 
    mov     a13, a5 
    mov     a14, a6
    mov     a15, a7 
/* Call the C function. a0-a7 are saved. */
    callx8  a8
/* Reload alloc ptr and alloc limit */
    l32r    a9, __caml_young_ptr
    l32r    a10, __caml_young_limit
    ssi     f1, a9, 0 /* a9 still points to caml_young_ptr */
    ssi     f2, a10, 0 
/* Return */
    ret
    .type   caml_c_call, %function
    .size   caml_c_call, .-caml_c_call

    .literal_position
    
/* Start the OCalm program - CALL8*/
    .align  4
    .globl  caml_start_program
caml_start_program:
    entry   sp, 4*(4+6+8)
.literal __caml_program, caml_program
    l32r    a11, __caml_program 

/* Code shared with caml_callback */
/* Address of OCaml code to call is in a11 */
/* Arguments to the OCaml code are in a2...a7 */
/* Nothing is saved. */

 /* Base windowed call is 16 bytes
  * Stack uses 12 bytes for bottom, last_return, gc
  * + 8 bytes for caml_exception_pointer, .Ltrap_handler
  */
.Ljump_to_caml:
/* Setup a callback link on the stack */
    l32r    a8, __caml_bottom_of_stack
    l32r    a9, __caml_last_return_address
    l32r    a10, __caml_gc_regs
    l32i    a8, a8, 0
    l32i    a9, a9, 0
    l32i    a10, a10, 0 
    s32i    a8, sp, 8 
    s32i    a9, sp, 12
    s32i    a10, sp, 16
/* Setup a trap frame to catch exceptions escaping the OCaml code */
    l32r    a8, __caml_exception_pointer
    .literal .trap_handler, trap_handler
    l32r    a9, .trap_handler
    l32i    a8, a8, 0
    s32i    a8, sp, 0 /* exn ptr */
    s32i    a9, sp, 4 /* trap handler */
    wfr     f0, sp  /* Save trap pointer */
/* Reload allocation pointers */
    l32r    a8, __caml_young_ptr
    lsi     f1, a8, 0
    l32r    a8, __caml_young_limit
    lsi     f2, a8, 0
/* Move arguments for C ABI call */
    mov     a8, a11
/* Call the OCaml code */
    callx0  a8
.Lcaml_retaddr:
/* Pop the trap frame, restoring caml_exception_pointer */
    l32r    a8, __caml_exception_pointer
    l32i    a9, sp, 0
    s32i    a9, a8, 0
/* Pop the callback link, restoring the global variables */
.Lreturn_result:
    l32r    a8, __caml_bottom_of_stack
    l32i    a9, sp, 0
    s32i    a8, a8, 0
    l32r    a9, __caml_last_return_address
    l32i    a8, sp, 4
    s32i    a9, a8, 0
    l32r    a8, __caml_gc_regs
    l32i    a9, sp, 8
    s32i    a9, a8, 0
/* Update allocation pointer */
    l32r    a8, __caml_young_ptr
    ssi     f1, a8, 0
    retw
    .type   .Lcaml_retaddr, %function
    .size   .Lcaml_retaddr, .-.Lcaml_retaddr
    .type   caml_start_program, %function
    .size   caml_start_program, .-caml_start_program

    .literal_position
    

    .align 4
    .globl trap_handler
trap_handler:
/* Save exception pointer */
    l32r    a11, __caml_exception_pointer
    ssi     f0, a11, 0
/* Encode exception bucket as an exception result */
    movi    a11, 2
    or      a2, a2, a11
/* Return it */
    j       .Lreturn_result 
    .type   trap_handler, %function
    .size   trap_handler, .-trap_handler

    .literal_position
    

/* Raise an exception from OCaml */
/* CALL0 */
    .align  4
    .globl  caml_raise_exn
caml_raise_exn: 
/* Test if backtrace is active */
    .literal __caml_backtrace_active, caml_backtrace_active
    l32r    a3, __caml_backtrace_active
    l32i    a3, a3, 0
    beqz    a3, 1f
/* Give exception bucket as argument */
    mov     a6, a2 
/* Stash the backtrace */
    mov     a7, a0 
    mov     a8, sp 
    rfr     a9, f0 
    call4   caml_stash_backtrace
1:
    rfr     a0, f0 /* Read trap handler dest */
    ret 
    .literal_position
    

/* Raise an exception from C */
/* Check window stuff */
    .align 4
    .globl caml_raise_exception 
caml_raise_exception:
    entry   sp, 4*4
/* Set windowstart bit */
    rsr.windowbase a12 
    movi.n  a11, 1
    ssl     a12 
    sll     a11, a11 
    wsr.windowstart a11 
    rsync 
/* Reload trap ptr, alloc ptr and alloc limit */
    l32r    a12, __caml_exception_pointer
    l32r    a13, __caml_young_ptr
    l32r    a14, __caml_young_limit
    lsi     f0, a12, 0
    lsi     f1, a13, 0
    lsi     f2, a14, 0
/* Test if backtrace is active */
    l32r    a3, __caml_backtrace_active
    l32i    a3, a3, 0 
    l32i    a3, a3, 0
    beqz    a3, 1f
/* Give exception bucket as argument */
    mov     a6, a2 
/* Stash the backtrace */
    l32r    a7, __caml_last_return_address
    l32i    a7, a7, 0
    l32r    a8, __caml_bottom_of_stack
    l32i    a8, a8, 0
    rfr     a9, f0
    call4   caml_stash_backtrace 
1:
    rfr     a0, f0 /* Read trap handler dest */
    ret 

    .type   caml_raise_exception, %function
    .size   caml_raise_exception, .-caml_raise_exception


/* Callback from C to OCaml */

    .align  4
    .globl  caml_callback_exn  
caml_callback_exn:
    entry   sp, (4+6+8)*4
/* Initial shuffling of argments (a2 = closure, a3 = first arg) */
    mov     a11, a2 
    mov     a2, a3      /* a2 = first arg */
    mov     a3, a11     /* a3 = closure environment */
    l32i    a11, a11, 0 /* code pointer */
    j       .Ljump_to_caml
    .type   caml_callback_exn, %function
    .size   caml_callback_exn, .-caml_callback_exn

    .literal_position
    
    .align  4
    .globl  caml_callback2_exn  
caml_callback2_exn:
    entry   sp, (4+6+8)*4
/* Initial shuffling of argments (a2 = closure, a3 = arg1, a4 = arg2) */
    mov     a11, a2 
    mov     a2, a3      /* a2 = first arg */
    mov     a3, a4      /* a3 = second arg */
    mov     a4, a11     /* a4 = closure environment */
    l32i    a11, a11, 0 /* code pointer */
    j       .Ljump_to_caml
    .type   caml_callback2_exn, %function
    .size   caml_callback2_exn, .-caml_callback2_exn

    .literal_position
    
    .align  4
    .globl  caml_callback3_exn  
caml_callback3_exn:
    entry   sp, (4+6+8)*4
/* Initial shuffling of argments (a2 = closure, a3 = arg1, a4 = arg2, a5 = arg3) */
    mov     a11, a2 
    mov     a2, a3      /* a2 = first arg */
    mov     a3, a4      /* a3 = first arg */
    mov     a4, a5      /* a4 = first arg */
    mov     a5, a11     /* a5 = closure environment */
    l32i    a11, a11, 0 /* code pointer */
    j       .Ljump_to_caml
    .type   caml_callback3_exn, %function
    .size   caml_callback3_exn, .-caml_callback3_exn

    .literal_position
    

    .align  4
    .globl  caml_ml_array_bound_error
caml_ml_array_bound_error:
/* Load address of [caml_array_bound_error] in */ 
    .literal __caml_array_bound_error, caml_array_bound_error
    l32r    a9, __caml_array_bound_error
/* Call that function */
    call0   caml_c_call 
    ret
    .type   caml_ml_array_bound_error, %function
    .size   caml_ml_array_bound_error, .-caml_ml_array_bound_error

    .literal_position

    .globl  caml_system__code_end
caml_system__code_end:

/* GC roots for callback */

    .data
    .align  4
    .globl  caml_system__frametable
caml_system__frametable:
    .word   1               /* one descriptor */
    .word   .Lcaml_retaddr  /* return address into callback */
    .short  -1              /* negative frame size => use callback link */
    .short  0               /* no roots */
    .align  2
    .type   caml_system__frametable, %object
    .size   caml_system__frametable, .-caml_system__frametable

/* Mark stack as non-executable */
    .section .note.GNU-stack,"",%progbits
