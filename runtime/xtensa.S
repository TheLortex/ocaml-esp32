/**************************************************************************/
/*                                                                        */
/*                                 OCaml                                  */
/*                                                                        */
/*       Lucas Pluvinage, OCaml Labs intern, ENS Paris student            */
/*                                                                        */
/*                                                                        */
/*   All rights reserved.  This file is distributed under the terms of    */
/*   the GNU Lesser General Public License version 2.1, with the          */
/*   special exception on linking described in the file LICENSE.          */
/*                                                                        */
/**************************************************************************/

#include "caml/m.h"

    .global caml_garbage_collection
    .literal_position


// trap_ptr	.req	f0
// alloc_ptr	.req	f1
// domain_state_ptr	.req	f2


        .set    domain_curr_field, 0
#define DOMAIN_STATE(c_type, name) \
        .equ    domain_field_caml_##name, domain_curr_field ; \
        .set    domain_curr_field, domain_curr_field + 1
#include "../runtime/caml/domain_state.tbl"
#undef DOMAIN_STATE

#define Caml_state(var) 8*domain_field_caml_##var


    .text
    .literal_position
    .globl caml_system__code_begin
caml_system__code_begin:

    .align  4
    .globl  caml_call_gc
/*
    Calls generated by emit.mlp
    Updates f1 and f2 after garbage collection.
    -> Called using CALL0 ABI.
    a2-a11 are saved.
 */
caml_call_gc:
.Lcaml_call_gc:
/* Record return address */
    rfr     a15, f2
    s32i    a0, a15, Caml_state(last_return_address)
/* Record lowest stack address */
    s32i    sp, a15, Caml_state(bottom_of_stack)
/* Save stack pointer */
    s32i    sp, a15, Caml_state(gc_regs)
/* Save allocation pointer */
    ssi     f1, a15, Caml_state(young_ptr)
/* Save trap pointer */
    ssi     f0, a15, Caml_state(exception_pointer)
/* Call the garbage collector: C call saves a0-a11 */
    call12   caml_garbage_collection
/* Reload new allocation pointer and limit */
    rfr     a15, f2
    lsi     f1, a15, Caml_state(young_ptr) /* Load new f1 */
/* Return to caller */
    ret
    .type   caml_call_gc, %function
    .size   caml_call_gc, .-caml_call_gc

    .literal_position


    .align  4
    .globl  caml_alloc1
/*
-> Called using CALL0 ABI.
Destroys every register
 */
caml_alloc1:
.Lcaml_alloc1:
    rfr     a11, f1        /* Read alloc ptr */
    addi    a11, a11, -8          /* Perform update */
    wfr     f1, a11        /* Save alloc ptr */
    rfr     a15, f2 /* Read domain state */
    l32i    a12, a15, Caml_state(young_limit) /* Read alloc limit */
    bltu    a11, a12, caml_call_gc  /* Call gc on overflow */
    ret /* Otherwise returns. */

    .align  4
    .globl  caml_alloc2
/*
-> Called using CALL0 ABI.
Destroys every register
 */
caml_alloc2:
.Lcaml_alloc2:
    rfr     a11, f1        /* Read alloc ptr */
    addi    a11, a11, -12          /* Perform update */
    wfr     f1, a11        /* Save alloc ptr */
    rfr     a15, f2 /* Read domain state */
    l32i    a12, a15, Caml_state(young_limit) /* Read alloc limit */
    bltu    a11, a12, caml_call_gc  /* Call gc on overflow */
    ret /* Otherwise returns. */

    .align  4
    .globl  caml_alloc3
/*
-> Called using CALL0 ABI.
Destroys every register
 */
caml_alloc3:
.Lcaml_alloc3:
    rfr     a11, f1        /* Read alloc ptr */
    addi    a11, a11, -16          /* Perform update */
    wfr     f1, a11        /* Save alloc ptr */
    rfr     a15, f2 /* Read domain state */
    l32i    a12, a15, Caml_state(young_limit) /* Read alloc limit */
    bltu    a11, a12, caml_call_gc  /* Call gc on overflow */
    ret /* Otherwise returns. */

/* N bytes allocation, N is in a2
-> Called using CALL0 ABI.
Destroys every register except a2
*/
    .align  4
    .globl  caml_allocN
caml_allocN:
.Lcaml_allocN:
    rfr     a11, f1      /* Read alloc ptr */
    sub     a11, a11, a2        /* Perform update */
    wfr     f1, a11      /* Save alloc ptr */
    rfr     a15, f2 /* Read domain state */
    l32i    a12, a15, Caml_state(young_limit) /* Read alloc limit */
    bltu    a11, a12, caml_call_gc  /* Call gc on overflow */
    ret /* Otherwise returns. */


    .literal_position

/* Call a C function from OCaml
-> Called using CALL0 ABI.
a6 to a11 contains function arguments
a4 contains C function to call.
a2 and a3 should be saved.
-> C is called using CALL4 ABI.
*/
    .align  4
    .globl  caml_c_call
caml_c_call:
/* Record lowest stack address and return address */
    rfr     a15, f2
    s32i    a0, a15, Caml_state(last_return_address)
    s32i    sp, a15, Caml_state(bottom_of_stack)
/* Make the exception handler alloc ptr available to the C code */
    ssi     f1, a15, Caml_state(young_ptr)
    ssi     f0, a15, Caml_state(exception_pointer)
/* Call the C function. a0-a3 are saved. */
    callx4  a4
/* Reload alloc ptr into register */
    rfr     a15, f2
    lsi     f1, a15, Caml_state(young_ptr)
/* Return */
    ret
    .type   caml_c_call, %function
    .size   caml_c_call, .-caml_c_call

    .literal_position

/* Start the OCalm program - CALL8*/
    .align  4
    .globl  caml_start_program
caml_start_program:
    entry   sp, (4+8+4+4)*4
.literal __caml_program, caml_program
    l32r    a11, __caml_program

/* Code shared with caml_callback */
/* Address of OCaml code to call is in a11 */
/* Arguments to the OCaml code are in a2...a7 */
/* Nothing is saved. */
 /* Base windowed call is 16 bytes (4 words)
  * CALL12 support: 32 bytes (8 words)
  * Stack uses 16 bytes for bottom, last_return, gc, a0
  * + 8 bytes for trap: caml_exception_pointer, .Ltrap_handler aligned (4-word boundary)
  */
.Ljump_to_caml:
/* Setup a callback link on the stack */
    .literal __Caml_state, Caml_state
    l32r    a15, __Caml_state /* Load caml domain state pointer */
    l32i    a15, a15, 0
    wfr     f2, a15 /* Save it. */
    l32i    a8, a15, Caml_state(bottom_of_stack)
    l32i    a9, a15, Caml_state(last_return_address)
    l32i    a10, a15, Caml_state(gc_regs)
    s32i    a8, sp, 16
    s32i    a9, sp, 20
    s32i    a10, sp, 24
/* Save return address */
    s32i    a0, sp, 28
/* Setup a trap frame to catch exceptions escaping the OCaml code */
    .literal .trap_handler, trap_handler
    l32r    a9, .trap_handler
    l32i    a8, a15, Caml_state(exception_pointer)
    s32i    a8, sp, 0 /* exn ptr */
    s32i    a9, sp, 4 /* trap handler */
    wfr     f0, sp  /* Save trap pointer */
/* Reload allocation pointers */
    lsi     f1, a15, Caml_state(young_ptr)
/* Move arguments for C ABI call */
    mov     a8, a11
/* Call the OCaml code */
    callx0  a8
.Lcaml_retaddr:
/* Pop the trap frame, restoring caml_exception_pointer */
    rfr     a15, f2
    l32i    a9, sp, 0
    s32i    a9, a15, Caml_state(exception_pointer)
    addi    a15, sp, 16
/* Fake call8 for correct movsp */
    movi    a0, 2
    slli	a0, a0, 30
    movsp   sp, a15
/* Pop the callback link, restoring the global variables */
.Lreturn_result:
    rfr     a15, f2
    l32i    a9, sp, 0
    s32i    a9, a15, Caml_state(bottom_of_stack)
    l32i    a9, sp, 4
    s32i    a9, a15, Caml_state(last_return_address)
    l32i    a9, sp, 8
    s32i    a9, a15, Caml_state(gc_regs)
/* Return address */
    l32i    a0, sp, 12
/* Update allocation pointer */
    ssi     f1, a15, Caml_state(young_ptr)
    retw
    .type   .Lcaml_retaddr, %function
    .size   .Lcaml_retaddr, .-.Lcaml_retaddr
    .type   caml_start_program, %function
    .size   caml_start_program, .-caml_start_program

    .literal_position


    .align 4
    .globl trap_handler
trap_handler:
/* Save exception pointer */
    rfr     a15, f2
    ssi     f0, a15, Caml_state(exception_pointer)
/* Encode exception bucket as an exception result */
    movi    a11, 2
    or      a2, a2, a11
/* Return it */
    j       .Lreturn_result
    .type   trap_handler, %function
    .size   trap_handler, .-trap_handler

    .literal_position


/* Raise an exception from OCaml */
/* CALL0 */
    .align  4
    .globl  caml_raise_exn
caml_raise_exn:
/* Test if backtrace is active */
    rfr     a15, f2
    l32i    a3, a15, Caml_state(backtrace_active)
    beqz    a3, 1f
/* Give exception bucket as argument */
    mov     a6, a2
/* Stash the backtrace */
    mov     a7, a0
    mov     a8, sp
    rfr     a9, f0
    call4   caml_stash_backtrace
1:
/* Cut stack at current trap handler */
    rfr     a15, f0
/* Pop previous trap handler */
    lsi     f0, a15, 0
/* Load trap destination in f5 (then it will be loaded in a0) */
    lsi     f5, a15, 4
/* Set new stack using movsp and a fake call8 */
    movi    a14, 2
    slli    a0, a14, 30
/* Pop exception handler */
    addi    a15, a15, 8
    movsp   sp, a15
    rfr     a0, f5
    ret
    .literal_position


/* Raise an exception from C */
/* Domain ptr in a2, bucket in a3. */
    .align 4
    .globl caml_raise_exception
caml_raise_exception:
    entry   sp, 16
/* Spill all registers on stack. saving a2 in a15 */
    mov     a15, a2
    movi    a2, 0
    syscall /* System call 0: flush all registers on stack. */
/* Store domain state pointer */
    wfr     f2, a15
/* Reload trap ptr and alloc ptr */
    lsi     f0, a15, Caml_state(exception_pointer)
    lsi     f1, a15, Caml_state(young_ptr)
/* Test if backtrace is active */
    l32i    a4, a15, Caml_state(backtrace_active)
    beqz    a4, 1f 
/* Exception bucket is preserved in callee-save register a3 */
    mov     a6, a3  /* Arg1: exception bucket*/
    l32i    a7, a15, Caml_state(last_return_address) 
    l32i    a8, a15, Caml_state(bottom_of_stack)
    rfr     a9, f0
    call4   caml_stash_backtrace 
    mov     a15, a2 /* Reload domain state */
1:
/* Cut stack at bottom of stack before C call to get back caller's spilled registers */
    l32i    sp, a15, Caml_state(bottom_of_stack)
/* Under SP there are 4 spilled registers of OCaml code caller */

/* Find stack pointer at current trap handler */
    rfr     a15, f0
/* Pop previous trap handler */
    lsi     f0, a15, 0
/* Load trap destination */
    l32i    a0, a15, 4
/* Erase two high bits */
    slli    a0, a0, 2
    srli    a0, a0, 2
/* Set as call4 */
    movi    a3, 1
    slli    a3, a3, 30
    or      a0, a3, a0
/* a15 holds new stack pointer */
    addi    a15, a15, 8
/* under a15 there will be a0-a3 registers updated on OCaml retw */
/* under sp there will be a0-a3 registers updated on exception retw */
    .globl after_syscall
after_syscall:
    l32e    a11, sp, -4 
    l32e    a12, sp, -8 
    l32e    a13, sp, -12
    l32e    a14, sp, -16
    s32e    a11, a15, -4 
    s32e    a12, a15, -8 
    s32e    a13, a15, -12
    s32e    a14, a15, -16
/* Store trap sp, that will be set in register on window underflow */
    s32e    a15, sp, -12 /* a1 */
    s32e    a2, sp, -8 /* a2 */
/* Jump on trap handler and underflow, restoring stack pointer. */
    retw

    .type   caml_raise_exception, %function
    .size   caml_raise_exception, .-caml_raise_exception


/* Callback from C to OCaml */

    .align  4
    .globl  caml_callback_asm
caml_callback_asm:
    entry   sp, (4+8+4+4)*4
/* Initial shuffling of argments (a2 = closure, a3 = first arg) */
    mov     a11, a2
    mov     a2, a3      /* a2 = first arg */
    mov     a3, a11     /* a3 = closure environment */
    l32i    a11, a11, 0 /* code pointer */
    j       .Ljump_to_caml
    .type   caml_callback_asm, %function
    .size   caml_callback_asm, .-caml_callback_asm

    .literal_position

    .align  4
    .globl  caml_callback2_asm
caml_callback2_asm:
    entry   sp, (4+8+4+4)*4
/* Initial shuffling of argments (a2 = closure, a3 = arg1, a4 = arg2) */
    mov     a11, a2
    mov     a2, a3      /* a2 = first arg */
    mov     a3, a4      /* a3 = second arg */
    mov     a4, a11     /* a4 = closure environment */
.literal __caml_apply2, caml_apply2
    l32r    a11, __caml_apply2
    j       .Ljump_to_caml
    .type   caml_callback2_asm, %function
    .size   caml_callback2_asm, .-caml_callback2_asm

    .literal_position

    .align  4
    .globl  caml_callback3_asm
caml_callback3_asm:
    entry   sp, (4+8+4+4)*4
/* Initial shuffling of argments (a2 = closure, a3 = arg1, a4 = arg2, a5 = arg3) */
    mov     a11, a2
    mov     a2, a3      /* a2 = first arg */
    mov     a3, a4      /* a3 = first arg */
    mov     a4, a5      /* a4 = first arg */
    mov     a5, a11     /* a5 = closure environment */
.literal __caml_apply3, caml_apply3
    l32r    a11, __caml_apply3
    j       .Ljump_to_caml
    .type   caml_callback3_asm, %function
    .size   caml_callback3_asm, .-caml_callback3_asm

    .literal_position


    .align  4
    .globl  caml_ml_array_bound_error
caml_ml_array_bound_error:
/* Load address of [caml_array_bound_error] in */
    .literal __caml_array_bound_error, caml_array_bound_error
    l32r    a9, __caml_array_bound_error
/* Call that function */
    call0   caml_c_call
    ret
    .type   caml_ml_array_bound_error, %function
    .size   caml_ml_array_bound_error, .-caml_ml_array_bound_error

    .literal_position

    .globl  caml_system__code_end
caml_system__code_end:

/* GC roots for callback */

    .data
    .align  4
    .globl  caml_system__frametable
caml_system__frametable:
    .word   1               /* one descriptor */
    .word   .Lcaml_retaddr  /* return address into callback */
    .short  -1              /* negative frame size => use callback link */
    .short  0               /* no roots */
    .align  2
    .type   caml_system__frametable, %object
    .size   caml_system__frametable, .-caml_system__frametable

/* Mark stack as non-executable */
    .section .note.GNU-stack,"",%progbits
