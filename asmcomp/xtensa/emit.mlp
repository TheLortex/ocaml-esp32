#2 "asmcomp/xtensa/emit.mlp"
(**************************************************************************)
(*                                                                        *)
(*                                 OCaml                                  *)
(*                                                                        *)
(*       Lucas Pluvinage, OCaml Labs intern, ENS Paris student            *)
(*                                                                        *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

open Arch
open Cmm
open Mach
open Linearize
open Emitaux
open Reg
open Proc
open Misc

(* Emission of Xtensa LX6 assembly code *)

let stack_offset = ref 0

let frame_size () =
  let sz =
    !stack_offset + (* Outgoing arguments *)
    num_stack_slots.(0) * 4 + (* Local integers *)
    (if !contains_calls then 4 else 0) (* Return address in case of call. *)
  in Misc.align sz 8

let function_name = ref ""
let pending_literals = ref []
let pending_strings = ref []
(* Entry point for tail recursive calls *)
let tailrec_entry_point = ref 0

let emit_label lbl =
  emit_string ".LC"; emit_int lbl

let emit_symbol s = Emitaux.emit_symbol '$' s 

let emit_reg = function 
  | {loc = Reg r} -> emit_string (register_name r)
  | _ -> fatal_error "Emit_xtensa.emit_reg"

let emit_int_const dst i = `	movi	{emit_reg dst}, {emit_int32 i}\n`

let emit_float_const dst_lo dst_hi f = 
  let high_bits = Int64.to_int32 (Int64.shift_right_logical f 32)
  and low_bits = Int64.to_int32 f in 
  `	movi	{emit_reg dst_lo}, {emit_int32 low_bits}\n`;
  `	movi	{emit_reg dst_hi}, {emit_int32 high_bits}\n`

(* Call to C using CALL4 ABI *)
let emit_call_to_C s = `	call4	{emit_symbol s}\n`

(* Call to C using CALL0 ABI *)
let emit_call_to_OCaml s = `	call0	{emit_symbol s}\n`

(* Choose between positive and negative addressing for load/store operations. *)
let emit_addressing_mode = function 
  | Iindexed ofs when ofs < 0 -> `e`
  | _ -> `i`

let same_location l1 l2 = match l1, l2 with 
  | Reg i1, Reg i2 -> i1 == i2 
  | _, _ -> false

(* Addressing relative to a register. Can only be positive *)
let emit_addressing addr r n = 
  match addr with
    Iindexed ofs ->
      `{emit_reg r.(n)}, {emit_int ofs}`

(* Position relative to stack pointer.
 * The stack frame is the following: 
 *  _______________________
 *  | Arguments (Incoming) |
 *   ---------------------- <- sp + !stack_offset + 4 * num_stack_slots.(0) + 4 if !contains_calls
 *  |   Local Variables    | |
 *   ---------------------- <- sp + !stack_offset
 *  | Arguments (Outgoing) | |
 *   ---------------------- <- sp
 *
 *)
let slot_offset loc _cl =
  let res = match loc with
    Incoming n ->
      assert (n >= 0);
      frame_size() + n
  | Local n -> 
      assert (n >= 0);
      !stack_offset + n * 4
  | Outgoing n ->
      assert (n >= 0);
      n
  in 
  res


(* Record live pointers at call points *)

let record_frame_label ?label live raise_ dbg =
  let lbl =
    match label with
    | None -> new_label ()
    | Some label -> label
  in
  let live_offset = ref [] in
  Reg.Set.iter
    (function
      | {typ = Val; loc = Reg r} ->(* Pointer in register: 2n+1 encoding of register index*)
          live_offset := ((r lsl 1) + 1) :: !live_offset
      | {typ = Val; loc = Stack s} as reg -> (* Pointer on stack: give stack offset *)
          live_offset := slot_offset s (register_class reg) :: !live_offset
      | {typ = Addr} as r ->
          Misc.fatal_error ("bad GC root " ^ Reg.name r)
      | _ -> ())
    live;
  record_frame_descr ~label:lbl ~frame_size:(frame_size())
    ~live_offset:!live_offset ~raise_frame:raise_ dbg;
  lbl

let record_frame ?label live raise_ dbg =
  let lbl = record_frame_label ?label live raise_ dbg in `{emit_label lbl}:`




(* Record calls to caml_ml_array_bound_error.
   In debug mode, we maintain one call to caml_ml_array_bound_error
   per bound check site. Otherwise, we can share a single call. *)

type bound_error_call =
  { bd_lbl: label;                    (* Entry label *)
    bd_frame_lbl: label }             (* Label of frame descriptor *)

let bound_error_sites = ref ([] : bound_error_call list)

let bound_error_label ?label dbg =
  if !Clflags.debug || !bound_error_sites = [] then begin
    let lbl_bound_error = new_label() in
    let lbl_frame = record_frame_label ?label Reg.Set.empty false dbg in
    bound_error_sites :=
      { bd_lbl = lbl_bound_error;
        bd_frame_lbl = lbl_frame } :: !bound_error_sites;
    lbl_bound_error
  end else begin
    let bd = List.hd !bound_error_sites in bd.bd_lbl
  end

let emit_call_bound_error bd =
  `{emit_label bd.bd_lbl}:	{emit_call_to_OCaml "caml_ml_array_bound_error"}\n`;
  `{emit_label bd.bd_frame_lbl}:\n`

let flush_strings () = 
  `.section .rodata\n`;
  let rec write_str = function 
    | [] -> ()
    | (label, value) :: next -> 
    begin
      `.align 4\n`;
      `{emit_label label}:\n`;
      `	.string	`; emit_string "\""; emit_string value; emit_string "\"";`\n`;
      write_str next
    end 
  in 
  write_str !pending_strings;
  pending_strings := []

let emit_load_symbol register symbol = 
  let n = new_label () in
  `.literal	{emit_label n}, {emit_symbol symbol}\n`;
  `	l32r	{emit_reg register}, {emit_label n}\n`


type comparison_op = Direct of string | Invert of string

let generate_comparison_op = function 
| Isigned Ceq ->    Direct ("beq" ) | Isigned Cne ->    Direct ("bne" ) | Isigned Cle -> Invert("bge") (* a1 <= a2 <=> a2 >= a1*)
| Isigned Cge ->    Direct ("bge" ) | Isigned Clt ->    Direct ("blt" ) | Isigned Cgt -> Invert("blt") (* a1 > a2 <=> a2 < a1*)
| Iunsigned Ceq ->  Direct ("beq" ) | Iunsigned Cne ->  Direct ("bne" ) | Iunsigned Cle -> Invert("bgeu")
| Iunsigned Cge ->  Direct ("bgeu") | Iunsigned Clt ->  Direct ("bltu") | Iunsigned Cgt -> Invert("bltu")

let generate_comparison_op_imm n = function 
| Isigned Ceq ->   "beqi", n | Isigned Cne ->    "bnei", n | Isigned Cle -> "blti", n+1
| Isigned Cge ->   "bgei", n  | Isigned Clt ->   "blti", n  | Isigned Cgt -> "bgei", n+1
| Iunsigned Ceq -> "beqi", n  | Iunsigned Cne -> "bnei", n  | Iunsigned Cle -> "bltui", n+1
| Iunsigned Cge -> "bgeui", n | Iunsigned Clt -> "bltui", n | Iunsigned Cgt -> "bgeui", n+1

let emit_comment str = 
  `	### {emit_string str} ###\n`


type imm_reg = Immediate of int | Register of Reg.t

(*
 * Conditional jump to label in 1 instruction.
 *)
let emit_if_then cmp r1 r2 label_then =
  match r2 with
  | Immediate n ->
    begin
      let cmp, n = generate_comparison_op_imm n cmp in
      `	{emit_string cmp}	{emit_reg r1}, {emit_int n}, {emit_label label_then} \n`;
    end
  | Register r2 ->
    begin
      match generate_comparison_op cmp with
      | Direct op -> `	{emit_string (op)} 	{emit_reg r1}, {emit_reg r2}, {emit_label label_then} \n`
      | Invert op -> `	{emit_string (op)} 	{emit_reg r2}, {emit_reg r1}, {emit_label label_then} \n`
    end

(* Compare r1 and r2 according to cmp, and set value to res in 3 or 4 instructions. *)
let emit_comparison cmp r1 r2 res =
  let cmp = generate_comparison_op cmp in
  let label_end = new_label () in
  if (same_location r1.loc res.loc || same_location r2.loc res.loc) then 
  begin 
    `	movi	a15, 1\n`;
    begin
      match cmp with 
      | Direct cmp -> (* r1 cmp r2 => res should be 1 *)
        `	{emit_string cmp} 	{emit_reg r1}, {emit_reg r2}, {emit_label label_end} \n`; 
      | Invert cmp -> (* r2 cmp r1 => res should be 1 *)
        `	{emit_string cmp} 	{emit_reg r2}, {emit_reg r1}, {emit_label label_end} \n`; 
    end;
    `	movi	a15, 0\n`;
    `{emit_label label_end}:\n`;
    `	mov 	{emit_reg res}, a15\n`
  end
  else
  begin 
    `	movi	{emit_reg res}, 1\n`;
    begin
      match cmp with 
      | Direct cmp -> (* r1 cmp r2 => res should be 1 *)
        `	{emit_string cmp} 	{emit_reg r1}, {emit_reg r2}, {emit_label label_end} \n`; 
      | Invert cmp -> (* r2 cmp r1 => res should be 1 *)
        `	{emit_string cmp} 	{emit_reg r2}, {emit_reg r1}, {emit_label label_end} \n`; 
    end;
    `	movi	{emit_reg res}, 0\n`;
    `{emit_label label_end}:\n`
  end

(* Compare r1 and r2 according to cmp, and set value to res in 3 or 4 instructions. *)
let emit_comparison_imm cmp r1 n res =
  let cmp, n = generate_comparison_op_imm n cmp in
  let label_end = new_label () in
  if (same_location r1.loc res.loc) then 
  begin
    `	movi	a15, 1\n`;
    `	{emit_string cmp}	{emit_reg r1}, {emit_int n}, {emit_label label_end} \n`;
    `	movi	a15, 0\n`;
    `{emit_label label_end}:\n`;
    `	mov	{emit_reg res}, a15\n`
  end
  else
  begin
    `	movi	{emit_reg res}, 1\n`;
    `	{emit_string cmp}	{emit_reg r1}, {emit_int n}, {emit_label label_end} \n`;
    `	movi	{emit_reg res}, 0\n`;
    `{emit_label label_end}:\n`
  end


let name_for_int_operation = function 
  | Iadd  -> "add", false
  | Isub  -> "sub", false
  | Idiv  -> "quos", false 
  | Imod  -> "rems", false
  | Imul  -> "mull", false
  | Imulh -> "mulsh", false
  | Iand  -> "and", false
  | Ior   -> "or", false
  | Ixor  -> "xor", false
  | Ilsl  -> "sll", true
  | Ilsr  -> "srl", true
  | Iasr  -> "sra", true
  | _ -> assert false

let emit_fill_shift_register instr reg = match instr with 
  | Ilsl -> `	ssl	{emit_reg reg}\n`
  | Iasr | Ilsr -> `	ssr	{emit_reg reg}\n`
  | _ -> assert false


    
let emit_stack r = 
  match r.loc with  
  | Stack s -> 
    let ofs = slot_offset s (register_class r) in 
    assert (ofs >= 0);
    `sp, {emit_int ofs}`
  | _ -> fatal_error "Emit_xtensa.emit_stack"

(* Because of windowed abi, must use movsp. *)
let emit_stack_adjustment n =
  if n = 0 then () else begin
    `	wfr 	f5, a0\n`;
    `	movi a15, 2\n`; (* Call8 emulation. *)
    `	slli a0, a15, 30\n`;
    `	addi	a15, sp, {emit_int n}\n`;
    `	movsp	sp, a15\n`;
    `	rfr 	a0, f5\n`;
  end

let output_epilogue f =
  let n = frame_size() in
  if n > 0 then begin
    emit_stack_adjustment n;
    f ();
    (* reset CFA back cause function body may continue *)
    cfi_adjust_cfa_offset n
  end else
    f ()




let emit_instruction i = 
  emit_debug_info i.dbg;
  match i.desc with 
    | Lend -> 
      emit_comment "End";
    | Lop(Imove | Ispill | Ireload) -> 
      emit_comment "Move | Spill | Reload";
      assert (Array.length i.res >= 1);
      assert (Array.length i.arg >= 1);
      begin
        let src = i.arg.(0) and dst = i.res.(0) in
        if src.loc = dst.loc then () else begin 
          match (src.loc, dst.loc) with 
          | Reg _, Reg _ -> 
              `	mov 	{emit_reg dst}, {emit_reg src}\n`
          | Reg _, Stack _ -> 
              `	s32i	{emit_reg src}, {emit_stack dst}\n`
          | Stack _, Reg _ -> 
              `	l32i	{emit_reg dst}, {emit_stack src}\n`
          | _, _ -> assert false
        end
      end
    | Lop(Iconst_int n) -> 
      emit_comment "Const int";
      assert (Array.length i.res >= 1);
      let n = Nativeint.to_int32 n in 
      emit_int_const i.res.(0) n 
    | Lop(Iconst_float f) -> 
      emit_comment "Const float";
      assert (Array.length i.res >= 2); 
      emit_float_const i.res.(0) i.res.(1) f
    | Lop(Iconst_symbol s) -> (* String emission *)
      emit_comment "Const symbol";
      assert (Array.length i.res >= 1);
      emit_load_symbol i.res.(0) s
    | Lop(Icall_ind {label_after;}) -> 
      emit_comment "Call_ind";
      assert (Array.length i.arg >= 1);
      `	callx0	{emit_reg i.arg.(0)}\n`;
      `{record_frame i.live false i.dbg ~label:label_after}\n`; 

    | Lop(Icall_imm { func; label_after; }) -> 
      emit_comment "Call imm";
      emit_call_to_OCaml func;
      `{record_frame i.live false i.dbg ~label:label_after}\n`;
    | Lop(Itailcall_ind { label_after = _; }) -> 
      emit_comment "Tailcall_ind";
      if !contains_calls then (* Reload ret addr *)
        `	l32i	a0, sp, {emit_int (frame_size() - 4)}\n`;
      output_epilogue begin fun () ->
        `	jx  	{emit_reg i.arg.(0)}\n`
      end
    | Lop(Itailcall_imm { func; label_after = _;}) ->
      emit_comment "Tailcall_imm"; 
      if func = !function_name then begin
        `	j.l  	{emit_label !tailrec_entry_point}, a15\n`
      end else begin
        if !contains_calls then (* Reload ret addr *)
          `	l32i	a0, sp, {emit_int (frame_size() - 4)}\n`;
        output_epilogue begin fun () ->
          let label = new_label () in
          `	.literal	{emit_label label}, {emit_symbol func}\n`; 
          `	l32r	a15, {emit_label label}\n`;
          `	jx  	a15\n`
        end
      end
      
    | Lop(Iextcall { func; alloc = false;}) -> 
      emit_comment "Extcall";
      `	{emit_call_to_C func}\n`
    | Lop(Iextcall { func; alloc = true; label_after; }) -> 
      emit_comment "Extcall alloc";
      emit_load_symbol (phys_reg 2 (* a4 *)) func;
      `	{emit_call_to_OCaml "caml_c_call"}\n`;
      `{record_frame i.live false i.dbg ~label:label_after}\n`
    | Lop(Istackoffset n) -> 
      emit_comment "Stackoffset";
      begin
        assert (n mod 8 = 0);
        emit_stack_adjustment (-n);
        stack_offset := !stack_offset + n;
      end
    | Lop(Iload((Double | Double_u), addr)) -> 
      emit_comment "Load double\n";
      assert (Array.length i.res >= 2);
      assert (Array.length i.arg >= 1);
      let addr' = offset_addressing addr 4 in
      begin
        if same_location i.res.(0).loc i.arg.(0).loc then begin (* Avoid address overwrite *)
          `	l32{emit_addressing_mode addr'}	{emit_reg i.res.(1)}, {emit_addressing addr' i.arg 0}\n`;
          `	l32{emit_addressing_mode addr}	{emit_reg i.res.(0)}, {emit_addressing addr i.arg 0}\n`
        end else begin
          `	l32{emit_addressing_mode addr}	{emit_reg i.res.(0)}, {emit_addressing addr i.arg 0}\n`;
          `	l32{emit_addressing_mode addr'}	{emit_reg i.res.(1)}, {emit_addressing addr' i.arg 0}\n`
        end
      end
    | Lop(Iload(size, addr)) -> 
      emit_comment "Load";
      assert (Array.length i.res >= 1);
      assert (Array.length i.arg >= 1);
      let r = i.res.(0) in
        let instr =
          match size with
            Byte_unsigned -> "l8u"
          | Byte_signed -> assert false
          | Sixteen_unsigned -> "l16u"
          | Sixteen_signed -> "l16s"
          | _ (* 32-bit quantities *) -> "l32" in
        `	{emit_string instr}{emit_addressing_mode addr}	{emit_reg r}, {emit_addressing addr i.arg 0}\n`;
    | Lop(Istore((Double | Double_u), addr, _)) -> 
      emit_comment "Store double\n";
      assert (Array.length i.arg >= 3);
      let addr' = offset_addressing addr 4 in
      begin
        `	s32{emit_addressing_mode addr}	{emit_reg i.arg.(0)}, {emit_addressing addr i.arg 2}\n`;
        `	s32{emit_addressing_mode addr'}	{emit_reg i.arg.(1)}, {emit_addressing addr' i.arg 2}\n`;
      end
    | Lop(Istore(size, addr, _)) -> 
      emit_comment "Store";
      let r = i.arg.(0) in
      let instr =
        match size with
          Byte_unsigned -> "s8"
        | Byte_signed -> "s8"
        | Sixteen_unsigned -> "s16"
        | Sixteen_signed -> "s16"
        | _ (* 32-bit quantities *) -> "s32" in
      `	{emit_string instr}{emit_addressing_mode addr}	{emit_reg r}, {emit_addressing addr i.arg 1}\n`;
    | Lop(Ialloc { words = n; label_after_call_gc; }) ->
      emit_comment "Alloc";
      let lbl_frame = 
        record_frame_label i.live false i.dbg ?label:label_after_call_gc
      in 
      begin match n with
        8 ->  `{emit_call_to_OCaml "caml_alloc1"}\n`
      | 12 -> `{emit_call_to_OCaml "caml_alloc2"}\n`
      | 16 -> `{emit_call_to_OCaml "caml_alloc3"}\n`
      |  _ -> emit_int_const (phys_reg 0) (Int32.of_int n);
              `{emit_call_to_OCaml "caml_allocN"}\n`
      end;
      `{emit_label lbl_frame}: \n`;
      `	rfr 	{emit_reg i.res.(0)}, f1\n`;
      `	addi	{emit_reg i.res.(0)}, {emit_reg i.res.(0)}, 4\n`
    | Lop(Iintop(Icomp cmp)) -> 
      emit_comment "Comparison";
      assert (Array.length i.arg >= 2);
      assert (Array.length i.res >= 1);
      emit_comparison cmp i.arg.(0) i.arg.(1) i.res.(0)
    | Lop(Iintop_imm(Icomp cmp, n)) -> 
      emit_comment "Comparison_imm";
      assert (Array.length i.res >= 1);
      assert (Array.length i.arg >= 2);
      emit_comparison_imm cmp i.arg.(0) n i.res.(0)
    | Lop(Iintop (Icheckbound { label_after_error ; } )) ->
      emit_comment "Checkbound"; 
      let lbl = bound_error_label ?label:label_after_error i.dbg in
      emit_if_then (Iunsigned Clt) i.arg.(0) (Register i.arg.(1)) lbl
    | Lop(Iintop_imm(Icheckbound { label_after_error; }, n)) ->
      emit_comment "Checkbound imm";
      let lbl = bound_error_label ?label:label_after_error i.dbg in 
      emit_if_then (Iunsigned Clt) i.arg.(0) (Immediate n) lbl
    | Lop(Iintop op) ->
      emit_comment "Intop";
      let instr, sar = name_for_int_operation op in
      (match sar with 
      | true ->  emit_fill_shift_register op i.arg.(1); `	{emit_string instr} 	{emit_reg i.res.(0)}, {emit_reg i.arg.(0)}\n`
      | false -> `	{emit_string instr} 	{emit_reg i.res.(0)}, {emit_reg i.arg.(0)}, {emit_reg i.arg.(1)}\n`)
    | Lop(Iintop_imm(op, n)) -> 
      emit_comment "Intop_imm";
      let instr,_ = name_for_int_operation op in 
      `	{emit_string instr}i	{emit_reg i.res.(0)}, {emit_reg i.arg.(0)}, {emit_int n}\n`
    | Lop(Inegf) ->
      `	wfr 	f8, {emit_reg i.arg.(1)}\n`;
      `	neg.s	f8, f8\n`;
      `	mov 	{emit_reg i.res.(0)}, {emit_reg i.arg.(0)}\n`;
      `	rfr 	{emit_reg i.res.(1)}, f8\n`;
    | Lop(Iabsf) -> 
      `	wfr 	f8, {emit_reg i.arg.(1)}\n`;
      `	abs.s	f8, f8\n`;
      `	mov 	{emit_reg i.res.(0)}, {emit_reg i.arg.(0)}\n`;
      `	rfr 	{emit_reg i.res.(1)}, f8\n`;
    | Lop(Ifloatofint) -> assert false (* Implemented by runtime ABI call *)
    | Lop(Iintoffloat) -> assert false (* Implemented by runtime ABI call *)
    | Lop(Iaddf | Isubf | Imulf | Idivf as _op) -> assert false (* Implemented by runtime ABI call *)
    | Lop(Iname_for_debugger _) -> ``
    | Lop(Ispecific(_)) ->  ``
    | Lreloadretaddr -> 
      emit_comment "Reloadretaddr";
      let n = frame_size() in (* First local variable is saved return address. *)
      `	l32i	a0, sp, {emit_int(n-4)}\n`
    | Lreturn -> 
      emit_comment "Return";
      output_epilogue begin fun () -> `	ret\n` end
    | Llabel(label) -> 
      emit_comment "Label";
      `	j 	{emit_label label}\n`;
      `.align 4\n`;
      emit_label label; `:\n`;
    | Lbranch(label) -> 
      emit_comment "Branch";
      `	j.l 	{emit_label label}, a15\n`; 
    | Lcondbranch(tst, lbl) -> 
      emit_comment ("Condbranch -> .LC"^(string_of_int lbl));
      assert (Array.length i.arg >= 1);
      begin
        match tst with
          | Itruetest -> `	bnez	{emit_reg i.arg.(0)}, {emit_label lbl}\n`
          | Ifalsetest -> `	beqz	{emit_reg i.arg.(0)}, {emit_label lbl}\n`
          | Iinttest cmp -> emit_if_then cmp i.arg.(0) (Register i.arg.(1)) lbl
          | Iinttest_imm(cmp, n) -> emit_if_then cmp i.arg.(0) (Immediate n) lbl
          | Ifloattest(_cmp, _neg) -> assert false
          | Ioddtest -> `	bbsi	{emit_reg i.arg.(0)}, 0, {emit_label lbl}\n`
          | Ieventest ->`	bbci	{emit_reg i.arg.(0)}, 0, {emit_label lbl}\n`
      end
    | Lcondbranch3(br1, br2, br3) -> 
      emit_comment ("Condbranch 3");
      assert (Array.length i.arg >= 1);
      (* Branch if less than 1 *)
      begin match br1 with
        None -> ()
      | Some lbl -> `	blti	{emit_reg i.arg.(0)}, 1, {emit_label lbl}\n`
      end;
      (* Branch if equal than 1 *)
      begin match br2 with
        None -> ()
      | Some lbl -> `	beqi	{emit_reg i.arg.(0)}, 1, {emit_label lbl}\n`
      end;
      (* Branch if greater than 1 *)
      begin match br3 with
        None -> ()
      | Some lbl -> 
        begin 
          `	bgei	{emit_reg i.arg.(0)}, 2, {emit_label lbl}\n`;
        end
      end;
    | Lswitch(jumptbl) -> 
      emit_comment "Switch"; 
      let switch_label = new_label () in
      let __switch_label = new_label () in
      `.literal	{emit_label __switch_label}, {emit_label switch_label}\n`;
      `	l32r	a15, {emit_label __switch_label}\n`; (* Load base address of labels in a15 *)
      `	addx4	a15, {emit_reg i.arg.(0)}, a15\n`; (* arg.(0)*4 + a15 *)
      `	l32i	a15, a15, 0\n`; (* Load label address *)
      `	jx  	a15\n`; (* Jump to label *)
      `.section	.rodata\n`;
      `.align	4\n`;
      emit_label switch_label; `:\n`;
      for j = 0 to Array.length jumptbl - 1 do
        `	.word	{emit_label jumptbl.(j)}\n`
      done;
      `.section	.text\n`
    | Lsetuptrap(label) ->
      emit_comment "Setup trap"; 
      `	call0 	{emit_label label}\n`
    | Lpushtrap -> 
      emit_comment "Push trap";
      stack_offset := !stack_offset + 16;
      emit_stack_adjustment (-16);
      `	ssi 	f0, sp, 0\n`; (* Store trap pointer *)
      `	s32i	a0, sp, 4\n`; (* Store return *)
      cfi_adjust_cfa_offset 16;
      `	wfr 	f0, sp\n`;  (* Save new trap pointer *)
    | Lpoptrap ->
      emit_comment "Pop trap";
      `	lsi 	f0, sp, 0\n`; (* Load trap pointer *)
      `	l32i	a0, sp, 4\n`; (* Load return *)
      emit_stack_adjustment 16;
      cfi_adjust_cfa_offset (-16);
      stack_offset := !stack_offset - 16;
    | Lraise(kind) ->
      emit_comment "Raise"; 
      begin match kind with 
      | Cmm.Raise_withtrace -> 
        `{emit_call_to_OCaml "caml_raise_exn"}\n`;
        `{record_frame Reg.Set.empty true i.dbg}\n`
      | Cmm.Raise_notrace ->
        `	rfr 	a15, f0 \n`; (* Load trap pointer *)
        `	lsi 	f0, a15, 0\n`; (* Load previous trap pointer *)
        `	lsi 	f5, a15, 4\n`; (* Load return address in f5 *)
        `	movi	a14, 2\n`; (* Fake call8. *)
        `	slli	a0, a14, 30\n`;
        `	addi	a15, a15, 16\n`;
        `	movsp	sp, a15\n`;
        `	rfr 	a0, f5\n`;
        `	ret\n`; (* Jump to a0. *)
      end



let rec emit_all instr = match instr.desc with 
  | Lend -> () 
  | _ -> emit_instruction instr; emit_all instr.next 

let fundecl fundecl = 
  function_name := fundecl.fun_name;
  tailrec_entry_point := new_label();
  stack_offset := 0;
  bound_error_sites := [];
  pending_literals := [];
  pending_strings := [];
  `.text\n`;
  `.literal_position\n`;
  `.align	4\n`;
  `.global	{emit_symbol fundecl.fun_name}\n`;
  `.type	{emit_symbol fundecl.fun_name}, @function\n`;
  `{emit_symbol fundecl.fun_name}:\n`;
  emit_debug_info fundecl.fun_dbg;
  cfi_startproc();
  let n = frame_size() in
  if n > 0 then begin
    ignore(emit_stack_adjustment (-n));
    if !contains_calls then begin
      cfi_offset ~reg:0 (* lr = a0 *) ~offset:(-4);
      `	s32i	a0, sp, {emit_int(n - 4)}\n`
    end
  end;
  `{emit_label !tailrec_entry_point}:\n`;
  emit_all fundecl.fun_body;
  flush_strings ();
  `.text\n`;
  `.literal_position\n`;
  List.iter emit_call_bound_error !bound_error_sites;
  cfi_endproc();
  `	.type	{emit_symbol fundecl.fun_name}, %function\n`;
  `	.size	{emit_symbol fundecl.fun_name}, .-{emit_symbol fundecl.fun_name}\n`


(* Emission of data *)

let emit_item = function
    Cglobal_symbol s -> `.globl	{emit_symbol s}\n`;
  | Cdefine_symbol s -> `{emit_symbol s}:\n`
  | Cint8 n ->  `	.byte	{emit_int n}\n`
  | Cint16 n -> `	.short	{emit_int n}\n`
  | Cint32 n -> `	.long	{emit_int32 (Nativeint.to_int32 n)}\n`
  | Cint n ->   `	.long	{emit_int32 (Nativeint.to_int32 n)}\n`
  | Csingle f -> emit_float32_directive "	.long	" (Int32.bits_of_float f)
  | Cdouble f -> emit_float64_split_directive "	.long	" (Int64.bits_of_float f)
  | Csymbol_address s -> `	.word	{emit_symbol s}\n`
  | Cstring s -> emit_string_directive "	.ascii	" s
  | Cskip n -> if n > 0 then `	.space	{emit_int n}\n`
  | Calign n -> `.align	{emit_int(Misc.log2 n)}\n`

let data l access_mode =
  begin
    match access_mode with 
    | Read_only -> `.section	.rodata\n`
    | Read_write -> `.section	.data\n`
  end;
  List.iter emit_item l


let begin_assembly() =
  let lbl_begin = Compilenv.make_symbol (Some "data_begin") in
  `.section	.rodata\n`;
  `.globl	{emit_symbol lbl_begin}\n`;
  `{emit_symbol lbl_begin}:\n`;
  let lbl_begin = Compilenv.make_symbol (Some "code_begin") in
  `.text\n`;
  `.globl	{emit_symbol lbl_begin}\n`;
  `{emit_symbol lbl_begin}:\n`

let end_assembly () =
  let lbl_end = Compilenv.make_symbol (Some "code_end") in
  `.text\n`;
  `.globl	{emit_symbol lbl_end}\n`;
  `{emit_symbol lbl_end}:\n`;
  let lbl_end = Compilenv.make_symbol (Some "data_end") in
  `.section	.rodata\n`;
  `.globl	{emit_symbol lbl_end}\n`;
  `{emit_symbol lbl_end}:\n`;
  `	.long	0\n`;
  let lbl = Compilenv.make_symbol (Some "frametable") in
  `.globl	{emit_symbol lbl}\n`;
  `.align	4\n`;
  `{emit_symbol lbl}:\n`;
  emit_frames
    { efa_code_label = (fun lbl ->
                       `	.type	{emit_label lbl}, %function\n`;
                       `	.word	{emit_label lbl}\n`);
      efa_data_label = (fun lbl ->
                       `	.type	{emit_label lbl}, %object\n`;
                       `	.word	{emit_label lbl}\n`);
      efa_16 = (fun n -> `	.short	{emit_int n}\n`);
      efa_32 = (fun n -> `	.long	{emit_int32 n}\n`);
      efa_word = (fun n -> `	.word	{emit_int n}\n`);
      efa_align = (fun n -> `	.align	{emit_int n}\n`);
      efa_label_rel = (fun lbl ofs ->
                           `	.word	{emit_label lbl} - . + {emit_int32 ofs}\n`);
      efa_def_label = (fun lbl -> `{emit_label lbl}:\n`);
      efa_string = (fun s -> emit_string_directive "	.asciz	" s) };
  `	.type	{emit_symbol lbl}, %object\n`;
  `	.size	{emit_symbol lbl}, .-{emit_symbol lbl}\n`;
